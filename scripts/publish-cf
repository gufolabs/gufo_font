#!/bin/sh
# ---------------------------------------------------------------------
# Gufo Font: Publish to CloudFlare Pages
# ---------------------------------------------------------------------
# Copyright (C) 2025, Gufo Labs
# ---------------------------------------------------------------------
set -e

# -----------------------------
# Config
# -----------------------------
PUBLISH_BRANCH="cf-pages"
SRC_DIR="dist/gufo-font"
LATEST_DIR="latest"
# -----------------------------

die() {
    echo "ERROR: $*" >&2
    exit 1
}

# Convert version to padded string
# 0.1 -> 0000-0001
# 1.2.3 -> 0001-0002-0003
padded_version() {
    v="$1"
    # Split by dot
    IFS=. read -r major minor patch <<EOF
$v
EOF
    # Default patch to 0 if missing
    patch=${patch:-0}
    printf "%04d-%04d-%05d\n" "$major" "$minor" "$patch"
}

stage_dir() {
    dir="$1"
    mkdir -p "$dir" || die "Cannot create directory $dir"
    echo "Copying artifacts into $dir/"
    # Clean old content
    rm -rf "${dir:?}/"* 2>/dev/null || true
    # Copy artifacts
    cp -R "$SRC_DIR/"* "$dir"/ || die "Failed to copy artifacts to $dir"
    # Stage for commit
    git add "$dir" || die "git add failed"
}

# Argument check
[ $# -eq 1 ] || die "Usage: $0 <version-tag>"
TAG="$1"

# Build artifacts must exist
[ -d "$SRC_DIR" ] || die "$SRC_DIR not found. Build first."

# Determine current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) \
    || die "Cannot determine current branch"

# Ensure publish branch exists locally or create a new orphan branch
if git show-ref --verify --quiet "refs/heads/$PUBLISH_BRANCH"; then
    git checkout "$PUBLISH_BRANCH" || die "Cannot switch to $PUBLISH_BRANCH"
elif git ls-remote --exit-code --heads origin "$PUBLISH_BRANCH" >/dev/null 2>&1; then
    git fetch origin "$PUBLISH_BRANCH:$PUBLISH_BRANCH" || die "Cannot fetch $PUBLISH_BRANCH"
    git checkout "$PUBLISH_BRANCH" || die "Cannot switch to $PUBLISH_BRANCH"
else
    git checkout --orphan "$PUBLISH_BRANCH" || die "Cannot create orphan $PUBLISH_BRANCH"
fi

# Check if it is latest release
max_version="0000-0000-0000"
for d in $(ls -1 | grep -E '^[0-9]+\.[0-9]+(\.[0-9]+)?$'); do
    [ -d "$d" ] || continue
    padded=$(padded_version "$d")
    [ "$padded" \> "$max_version" ] && max_version="$padded"
done

padded_tag=$(padded_version "$TAG")
if [ "$padded_tag" = "$max_version" ]; then
    UPDATE_LATEST=1
elif [ "$padded_tag" \> "$max_version" ]; then
    UPDATE_LATEST=1
fi

DST_DIR="$TAG"

stage_dir "$DST_DIR"
[ -n "$UPDATE_LATEST" ] && stage_dir "$LATEST_DIR"

# Commit only if changes exist
git diff --cached --quiet || (
    git commit -m "Publish $TAG" "$DST_DIR" "$LATEST_DIR" || die "git commit failed"
    #git push origin "$PUBLISH_BRANCH" || die "git push failed"
    echo "Published $TAG"
)

# Restore previous branch
git switch "$CURRENT_BRANCH" || die "Cannot return to $CURRENT_BRANCH"
